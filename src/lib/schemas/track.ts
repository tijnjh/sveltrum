import { userSchema } from './user'
import { z } from 'zod'

export const trackSchema = z.strictObject({
	artwork_url: z.url().nullable(),
	caption: z.string().nullable(),
	commentable: z.boolean(),
	comment_count: z.number().nullable(),
	created_at: z.iso.datetime(),
	description: z.string().nullable(),
	downloadable: z.boolean(),
	download_count: z.number().nullable(),
	duration: z.number(),
	full_duration: z.number(),
	embeddable_by: z.enum(['all', 'none', 'me']),
	genre: z.string().nullable(),
	has_downloads_left: z.boolean(),
	id: z.number(),
	kind: z.literal('track'),
	label_name: z.string().nullable(),
	last_modified: z.iso.datetime(),
	license: z.string(),
	likes_count: z.number().nullable(),
	permalink: z.string(),
	permalink_url: z.url(),
	playback_count: z.number().nullable(),
	public: z.boolean(),
	publisher_metadata: z
		.strictObject({
			id: z.number(),
			urn: z.string(),
			artist: z.string().optional(),
			publisher: z.string().optional(),
			album_title: z.string().optional(),
			contains_music: z.boolean().optional(),
			upc_or_ean: z.string().optional(),
			iswc: z.string().optional(),
			isrc: z.string().optional(),
			explicit: z.boolean().optional(),
			p_line: z.string().optional(),
			p_line_for_display: z.string().optional(),
			c_line: z.string().optional(),
			c_line_for_display: z.string().optional(),
			writer_composer: z.string().optional(),
			release_title: z.string().optional(),
		})
		.nullable(),
	purchase_title: z.string().nullable(),
	purchase_url: z.url().nullable(),
	release_date: z.string().nullable(),
	reposts_count: z.number(),
	secret_token: z.string().nullable(),
	sharing: z.enum(['public', 'private']),
	state: z.enum(['finished', 'processing']),
	streamable: z.boolean(),
	tag_list: z.string(),
	title: z.string(),
	uri: z.url(),
	urn: z.string(),
	user_id: z.number(),
	visuals: z
		.strictObject({
			urn: z.string(),
			enabled: z.boolean(),
			visuals: z
				.strictObject({
					urn: z.string(),
					entry_time: z.number(),
					visual_url: z.url(),
					link: z.url().optional(),
				})
				.array(),
			tracking: z.null(),
		})
		.nullable(),
	waveform_url: z.url(),
	display_date: z.iso.datetime(),
	media: z.strictObject({
		transcodings: z.array(
			z.strictObject({
				url: z.url(),
				preset: z.enum([
					'opus_0_0',
					'aac_160k',
					'mp3_0_0',
					'abr_sq',
					'mp3_1_0',
					'mp3_0_1',
					'mp3_standard',
				]),
				duration: z.number(),
				snipped: z.boolean(),
				format: z.strictObject({
					protocol: z.enum([
						'hls',
						'progressive',
						'ctr-encrypted-hls',
						'cbc-encrypted-hls',
					]),
					mime_type: z.enum([
						'audio/mp4; codecs="mp4a.40.2"',
						'audio/mpegurl',
						'audio/mpeg',
						'audio/ogg; codecs="opus"',
					]),
				}),
				quality: z.literal('sq'),
				is_legacy_transcoding: z.boolean(),
			}),
		),
	}),
	station_urn: z.string(),
	station_permalink: z.string(),
	track_authorization: z.string(),
	monetization_model: z.enum([
		'AD_SUPPORTED',
		'BLACKBOX',
		'NOT_APPLICABLE',
		'SUB_HIGH_TIER',
	]),
	policy: z.enum(['MONETIZE', 'BLOCK', 'SNIP', 'ALLOW']),
	user: userSchema,
})

export type Track = z.output<typeof trackSchema>
