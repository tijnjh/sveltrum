import { User } from './user'
import * as v from 'valibot'

export const Track = v.strictObject({
	artwork_url: v.nullable(v.pipe(v.string(), v.url())),
	caption: v.nullable(v.string()),
	comment_count: v.nullable(v.number()),
	commentable: v.boolean(),
	created_at: v.pipe(v.string(), v.isoTimestamp()),
	description: v.nullable(v.string()),
	display_date: v.pipe(v.string(), v.isoTimestamp()),
	download_count: v.nullable(v.number()),
	downloadable: v.boolean(),
	duration: v.number(),
	embeddable_by: v.picklist(['all', 'none', 'me']),
	full_duration: v.number(),
	genre: v.nullable(v.string()),
	has_downloads_left: v.boolean(),
	id: v.number(),
	kind: v.literal('track'),
	label_name: v.nullable(v.string()),
	last_modified: v.pipe(v.string(), v.isoTimestamp()),
	license: v.string(),
	likes_count: v.nullable(v.number()),
	media: v.strictObject({
		transcodings: v.array(
			v.strictObject({
				url: v.pipe(v.string(), v.url()),
				preset: v.picklist([
					'opus_0_0',
					'aac_160k',
					'mp3_0_0',
					'abr_sq',
					'mp3_1_0',
					'mp3_0_1',
					'mp3_standard',
				]),
				duration: v.number(),
				snipped: v.boolean(),
				format: v.strictObject({
					protocol: v.picklist([
						'hls',
						'progressive',
						'ctr-encrypted-hls',
						'cbc-encrypted-hls',
					]),
					mime_type: v.picklist([
						'audio/mp4; codecs="mp4a.40.2"',
						'audio/mpegurl',
						'audio/mpeg',
						'audio/ogg; codecs="opus"',
					]),
				}),
				quality: v.literal('sq'),
				is_legacy_transcoding: v.boolean(),
			}),
		),
	}),
	monetization_model: v.picklist([
		'AD_SUPPORTED',
		'BLACKBOX',
		'NOT_APPLICABLE',
		'SUB_HIGH_TIER',
	]),
	permalink: v.string(),
	permalink_url: v.pipe(v.string(), v.url()),
	playback_count: v.nullable(v.number()),
	policy: v.picklist(['MONETIZE', 'BLOCK', 'SNIP', 'ALLOW']),
	public: v.boolean(),
	publisher_metadata: v.nullable(
		v.strictObject({
			id: v.number(),
			urn: v.string(),
			artist: v.optional(v.string()),
			publisher: v.optional(v.string()),
			album_title: v.optional(v.string()),
			contains_music: v.optional(v.boolean()),
			upc_or_ean: v.optional(v.string()),
			iswc: v.optional(v.string()),
			isrc: v.optional(v.string()),
			explicit: v.optional(v.boolean()),
			p_line: v.optional(v.string()),
			p_line_for_display: v.optional(v.string()),
			c_line: v.optional(v.string()),
			c_line_for_display: v.optional(v.string()),
			writer_composer: v.optional(v.string()),
			release_title: v.optional(v.string()),
		}),
	),
	purchase_title: v.nullable(v.string()),
	purchase_url: v.nullable(v.pipe(v.string(), v.url())),
	release_date: v.nullable(v.string()),
	reposts_count: v.number(),
	secret_token: v.nullable(v.string()),
	sharing: v.picklist(['public', 'private']),
	state: v.picklist(['finished', 'processing']),
	station_permalink: v.string(),
	station_urn: v.string(),
	streamable: v.boolean(),
	tag_list: v.string(),
	title: v.string(),
	track_authorization: v.string(),
	uri: v.pipe(v.string(), v.url()),
	urn: v.string(),
	user: User,
	user_id: v.number(),
	visuals: v.nullable(
		v.strictObject({
			urn: v.string(),
			enabled: v.boolean(),
			visuals: v.array(
				v.strictObject({
					urn: v.string(),
					entry_time: v.number(),
					visual_url: v.pipe(v.string(), v.url()),
					link: v.optional(v.pipe(v.string(), v.url())),
				}),
			),
			tracking: v.null(),
		}),
	),
	waveform_url: v.pipe(v.string(), v.url()),
})

export type Track = v.InferOutput<typeof Track>
