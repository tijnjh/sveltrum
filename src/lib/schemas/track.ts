import { User } from "./user";
import * as v from "valibot";

export const Track = v.strictObject({
  artwork_url: v.nullable(v.pipe(v.string(), v.url())),
  caption: v.nullable(v.string()),
  comment_count: v.nullable(v.number()),
  commentable: v.boolean(),
  created_at: v.pipe(v.string(), v.isoTimestamp()),
  description: v.nullable(v.string()),
  display_date: v.pipe(v.string(), v.isoTimestamp()),
  download_count: v.nullable(v.number()),
  downloadable: v.boolean(),
  duration: v.number(),
  embeddable_by: v.picklist(["all", "none", "me"]),
  full_duration: v.number(),
  genre: v.nullable(v.string()),
  has_downloads_left: v.boolean(),
  id: v.number(),
  kind: v.literal("track"),
  label_name: v.nullable(v.string()),
  last_modified: v.pipe(v.string(), v.isoTimestamp()),
  license: v.string(),
  likes_count: v.nullable(v.number()),
  media: v.strictObject({
    transcodings: v.array(
      v.strictObject({
        url: v.pipe(v.string(), v.url()),
        preset: v.picklist([
          "opus_0_0",
          "aac_160k",
          "mp3_0_0",
          "abr_sq",
          "mp3_1_0",
          "mp3_0_1",
          "mp3_standard",
        ]),
        duration: v.number(),
        snipped: v.boolean(),
        format: v.strictObject({
          protocol: v.picklist([
            "hls",
            "progressive",
            "ctr-encrypted-hls",
            "cbc-encrypted-hls",
          ]),
          mime_type: v.picklist([
            'audio/mp4; codecs="mp4a.40.2"',
            "audio/mpegurl",
            "audio/mpeg",
            'audio/ogg; codecs="opus"',
          ]),
        }),
        quality: v.literal("sq"),
        is_legacy_transcoding: v.boolean(),
      }),
    ),
  }),
  monetization_model: v.picklist([
    "AD_SUPPORTED",
    "BLACKBOX",
    "NOT_APPLICABLE",
    "SUB_HIGH_TIER",
  ]),
  permalink: v.string(),
  permalink_url: v.pipe(v.string(), v.url()),
  playback_count: v.nullable(v.number()),
  policy: v.picklist(["MONETIZE", "BLOCK", "SNIP", "ALLOW"]),
  public: v.boolean(),
  publisher_metadata: v.nullable(
    v.strictObject({
      id: v.number(),
      urn: v.string(),
      artist: v.optional(v.string()),
      publisher: v.optional(v.string()),
      album_title: v.optional(v.string()),
      contains_music: v.optional(v.boolean()),
      upc_or_ean: v.optional(v.string()),
      iswc: v.optional(v.string()),
      isrc: v.optional(v.string()),
      explicit: v.optional(v.boolean()),
      p_line: v.optional(v.string()),
      p_line_for_display: v.optional(v.string()),
      c_line: v.optional(v.string()),
      c_line_for_display: v.optional(v.string()),
      writer_composer: v.optional(v.string()),
      release_title: v.optional(v.string()),
    }),
  ),
  purchase_title: v.nullable(v.string()),
  purchase_url: v.nullable(v.pipe(v.string(), v.url())),
  release_date: v.nullable(v.string()),
  reposts_count: v.number(),
  secret_token: v.nullable(v.string()),
  sharing: v.picklist(["public", "private"]),
  state: v.picklist(["finished", "processing"]),
  station_permalink: v.string(),
  station_urn: v.string(),
  streamable: v.boolean(),
  tag_list: v.string(),
  title: v.string(),
  track_authorization: v.string(),
  uri: v.pipe(v.string(), v.url()),
  urn: v.string(),
  user: User,
  user_id: v.number(),
  visuals: v.nullable(
    v.strictObject({
      urn: v.string(),
      enabled: v.boolean(),
      visuals: v.array(
        v.strictObject({
          urn: v.string(),
          entry_time: v.number(),
          visual_url: v.pipe(v.string(), v.url()),
          link: v.optional(v.pipe(v.string(), v.url())),
        }),
      ),
      tracking: v.null(),
    }),
  ),
  waveform_url: v.pipe(v.string(), v.url()),
});

export type Track = v.InferOutput<typeof Track>;
